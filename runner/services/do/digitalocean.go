package do

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/digitalocean/godo"
	"github.com/spaceuptech/launchpad/model"
	"golang.org/x/oauth2"
	"net/http"
)

// DigitalOcean is used to manage DO clients
type DigitalOcean struct {
	client *godo.Client
	token  string
	region string
	ctx    context.Context
}

// TokenSource -> pat
type TokenSource struct {
	AccessToken string
}

// Token function returns token to create client
func (t *TokenSource) Token() (*oauth2.Token, error) {
	token := &oauth2.Token{
		AccessToken: t.AccessToken,
	}
	return token, nil
}

// New returns DO object
func New(token string, region string) (*DigitalOcean, error) {
	// TODO: Create a godo DO client
	tokenSource := &TokenSource{
		AccessToken: token,
	}
	oauthClient := oauth2.NewClient(context.Background(), tokenSource)
	client := godo.NewClient(oauthClient)
	ctx := context.TODO()
	if client == nil {
		return nil, errors.New("Error in creating client")
	}
	return &DigitalOcean{client: client, token: token, region: region, ctx: ctx}, nil

}

// Apply is used for create/update operations on DB
func (do *DigitalOcean) Apply(service *model.ManagedService) error {
	// ref: https://medium.com/@l.peppoloni/how-to-improve-your-go-code-with-empty-structs-3bd0c66bc531
	// dbSizeSlug is a map which acts as a lookup table for db sizes
	type Empty struct{}
	dbSizeSlug := map[string]struct{}{
		"db-s-1vcpu-1gb":   Empty{}, // using empty struct consumes no storage space
		"db-s-1vcpu-2gb":   Empty{},
		"db-s-2vcpu-4gb":   Empty{},
		"db-s-4vcpu-8gb":   Empty{},
		"db-s-6vcpu-16gb":  Empty{},
		"db-s-8vcpu-32gb":  Empty{},
		"db-s-16vcpu-64gb": Empty{},
	}
	// ref: https://github.com/digitalocean/databases/tree/master/examples

	// Check if the request is valid
	if service.ServiceType == "database" && service.DataBase.Replication.ReplicationFactor == service.DataBase.Replication.Instances {
		sizeSlug := "db-s-" + string(service.DBResources.CPU) + "vcpu-" + string(service.DBResources.Memory) + "gb"
		if _, ok := dbSizeSlug[sizeSlug]; !ok {
			return errors.New("Invalid db size")
		}
		// list all database
		reqURL := "/v2/databases?tag_name=" + service.ProjectID //iff not found...create a new dB with tAG as ID/ProjectID
		res, err := http.Get(reqURL)
		if err != nil {
			err = fmt.Errorf("Error fetching list of databases %s", err)
			return err
		}
		res.Header.Add("Content-Type", "application/json")
		res.Header.Add("Authorization", ("Bearer")+do.token)
		listDB := new(DOdatabase)
		_ = json.NewDecoder(res.Body).Decode(listDB)

		// Check if database already exists!! use token to login! Else create a new DB
		if len(listDB.Databases) == 0 {
			// Create a new DB Cluster
			createRequest := &godo.DatabaseCreateRequest{
				Name:       service.ID,
				EngineSlug: service.DataBase.Type,
				Version:    service.DataBase.DataBaseVersion,
				Region:     do.region,
				SizeSlug:   sizeSlug,
				NumNodes:   service.DataBase.Replication.ReplicationFactor, //Value inclusinve of stand-by nodes
				Tags: []string{
					service.ID,
					service.ProjectID,
				},
			}
			doClient, _, err := do.client.Databases.Create(do.ctx, createRequest)
			// fmt.Println(cluster, err)
			if err != nil {
				err = fmt.Errorf("Error creating db cluster: %s", err)
				return err
			}
			// Let's create a new user named 'galaxy' .......#password is auto-generated
			addUserRequest := &godo.DatabaseCreateUserRequest{
				Name: "galaxy",
			}
			_, _, err = do.client.Databases.CreateUser(do.ctx, doClient.ID, addUserRequest)

			if err != nil {
				err = fmt.Errorf("Error creating db user: %s", err)
				return err
			}
			return nil
		}
		// TODO: Update an existing database i.e. resize it!
		// Since we already listed the databases..get the id of the db using tag!
		dbID := listDB.Databases[0].ID
		resizeRequest := &godo.DatabaseResizeRequest{
			SizeSlug: sizeSlug,
			NumNodes: service.DataBase.Replication.ReplicationFactor,
		}
		// DBID -> ID is generated by do...db to store our specified ID and their ID mapping??
		_, err = do.client.Databases.Resize(do.ctx, dbID, resizeRequest)
		if err != nil {
			err = fmt.Errorf("Error resizing db cluster: %s", err)
			return err
		}
		return nil
	}
	return errors.New("Invalid request received")
}

// Delete is used to delete the database cluster
func (do *DigitalOcean) Delete(id string) error {
	// TODO: delete a cluster!!
	_, err := do.client.Databases.Delete(do.ctx, id)
	if err != nil {
		err = fmt.Errorf("Error deleting db cluster: %s", err)
		return err
	}
	return nil
}

// GetServices returns the user details for the db
func (do *DigitalOcean) GetServices() (*model.GetServiceDetails, error) {
	// Retrieve an existing db cluster..it contains the user as well as the conenction details
	cluster, _, err := do.client.Databases.Get(do.ctx, "DBID")
	if err != nil {
		err = fmt.Errorf("Error fetching db details: %s", err)
		return nil, err
	}
	var uname string
	var password string
	for _, user := range cluster.Users {
		if user.Name == "galaxy" {
			uname = user.Name
			password = user.Password
		}
	}
	// Connection -> Public && PrivateConnection -> Private
	port := cluster.Connection.Port
	pubURI := cluster.Connection.URI
	prvURI := cluster.PrivateConnection.URI
	pubHost := cluster.Connection.Host
	prvHost := cluster.PrivateConnection.Host

	// getservice := new(model.GetServiceDetails)

	return &model.GetServiceDetails{
		PublicNw: model.PublicNw{
			Username: uname,
			Password: password,
			Port:     port,
			URI:      pubURI,
			Host:     pubHost,
		},
		PrivateNw: model.PrivateNw{
			Username: uname,
			Password: password,
			Port:     port,
			URI:      prvURI,
			Host:     prvHost,
		},
	}, nil
}

// GetAllTech is used to return all possible tech of the vendor selected
func GetAllTech() []string {
	return []string{"mysql", "postgres"}
}
